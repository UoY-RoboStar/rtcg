{{- define "system_includes" }}
#include "ros/ros.h"
#include "std_msgs/Bool.h"
#include "std_msgs/String.h"
{{- end -}}

{{- define "constants" }}
const int TIMEOUT_SEC     = 15;
const int INPUT_DELAY_SEC = 3;
{{- end -}}

{{- /* Expand to the name of a printf-style function used for logging. */ -}}
{{- define "log" -}}
  ROS_{{ toUpper . }}
{{- end -}}

{{- /* Calculates the ROS equivalent of a RoboStar type. */ -}}
{{- define "type" -}}
{{- /* TODO: add more types here */ -}}
std_msgs::String
{{- end -}}

{{- /* Returns the argument set of a timeout callback. */ -}}
{{- define "timeout_args" -}}
  const ros::TimerEvent& event
{{- end -}}

{{- /* Returns the argument set of an input-accepted callback. */ -}}
{{- define "in_callback_args" -}}
  const std_msgs::Bool::ConstPtr& msg
{{- end -}}

{{- /* Takes the Channel of an output callback, returns its argument set. */ -}}
{{- define "out_callback_args" -}}
  const {{ cppChannelType . }}Type::ConstPtr& msg
{{- end -}}

{{- /* Takes the Value received in an output callback, compares it against parameter `value`. */ -}}
{{- define "callback_compare" -}}
  std::string(msg->data.c_str()).compare("{{ .StringValue }}") == 0
{{- end -}}

{{- define "topic_name" -}}{{ toLowerUnderscored .Channel.Name }}{{- end -}}
{{- define "publisher_name" -}}{{ template "topic_name" . }}_pub{{- end -}}
{{- define "subscriber_name" -}}{{ template "topic_name" . }}_sub{{- end -}}

{{/* ROS initialisation code. */}}
{{- define "init" }}
  ros::init(argc, argv, "{{ .Name }}");
  ros::NodeHandle nh;

  // Publishers
{{-   range .Transitions.In }}
  auto {{ template "publisher_name" . }} = nh.advertise</* TODO */ sensor_msgs::BatteryState>("{{ template "topic_name" . }}", 1000);
{{-   end }}

  // Subscribers
{{-   if .Transitions.HasIn }}
  auto input_accepted_sub = nh.subscribe("input_accepted", 10, &StateMachine::inputAcceptedCallback, &stm);
{{-   end }}
{{   range .Transitions.Out }}
  auto {{ template "subscriber_name" . }} = nh.subscribe("{{ template "topic_name" . }}", 10, &StateMachine::{{ cppCallbackName .Channel }}, &stm)
{{-   end -}}

  // Timers
  auto timeout_timer = nh.createTimer(ros::Duration(TIMEOUT_SEC), &StateMachine::timeoutCallback, &stm);

{{- /* If the first state has an input transition, we delay the test to allow the SUT to warm up: */ -}}
{{-   if .Transitions.FirstStateHasIn }}
  auto input_delay_timer = nh.createTimer(ros::Duration(INPUT_DELAY_SEC, &StateMachine::, &stm);
{{-   end }}
  ros::Timer Pub_timer=nh.createTimer(ros::Duration(Init_Wait),Pub_timer_Callback);
{{- end -}}

{{-
/*
 * State machine
 */
-}}

{{- /* Adding the ROS handles to the state machine and its constructor: */ -}}

{{- define "stm_fields" }}

  // Publisher handles
{{-   range .Transitions.In }}
  ros::Publisher {{ template "publisher_name" . }}_;
{{-   end -}}

  // Subscriber handles
{{-   range .Transitions.Out }}
  ros::Subscriber {{ template "subscriber_name" . }}_;
{{-   end -}}
{{- end -}}

{{- define "stm_ctor_params" -}}
{{-   range $i, $t := .Transitions.In -}}
{{-     if ne $i 0 -}}, {{ end -}}
ros::Publisher {{ template "publisher_name" $t }}
{{-   end -}}
{{- end -}}

{{- define "stm_ctor_args" -}}
{{-   range $i, $t := .Transitions.In -}}
{{-     if ne $i 0 -}}, {{ end -}}
{{      template "publisher_name" $t }}
{{-   end -}}
{{- end -}}

{{- define "stm_ctor" }}
  // Install the publisher handles
{{-   range .Transitions.In }}
  {{ template "publisher_name" . }}_ = {{ template "publisher_name" . }};
{{-   end -}}
{{- end -}}

{{- /* Making sure ending the test ends ROS: */ -}}
{{- define "stm_end" }}
  ros::shutdown();
{{- end -}}

{{/*
The main loop or spin of the test driver, coming between initialisation and cleanup.

Should have an indent of 2, and has the state machine as dot.
*/}}
{{- define "spin" }}
  ros::spin();
{{- end -}}

{{/* We don't override "main_args" here. */}}

{{- template "base.cpp.tmpl" . -}}