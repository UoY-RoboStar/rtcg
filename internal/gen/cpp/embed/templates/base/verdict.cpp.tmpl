{{/*
verdict.cpp.tmpl expands into the verdict storage class.

It expects a slice of test ID strings as its dot.
*/}}
// Records information about test verdicts.
class Verdict
{
public:
  void dump(); // Outputs all test verdicts to log.
{{- range . }}
  void {{ . }}(rtcg::Outcome new_val); // Sets the outcome of {{ . }}.
{{- end }}
private:
{{- range . }}
  rtcg::Outcome {{ . }}_ = rtcg::Outcome::UNSET;
{{- end }}
};

void Verdict::dump()
{
{{- block "verdict_dump" . }}
  RTCG_INFO_STREAM("Final outcomes: " << std::endl);
{{-   range . }}
  switch ({{ . }}_) {
    case rtcg::Outcome::INC:
      RTCG_INFO_STREAM("  {{ . }} = " << rtcg::PRINT_COLOR::YELLOW << "inconclusive" << rtcg::PRINT_COLOR::ENDCOLOR << std::endl)
      break;
    case rtcg::Outcome::PASS:
      RTCG_INFO_STREAM("  {{ . }} = " << rtcg::PRINT_COLOR::GREEN << "pass" << rtcg::PRINT_COLOR::ENDCOLOR << std::endl)
      break;
    case rtcg::Outcome::FAIL:
      RTCG_INFO_STREAM("  {{ . }} = " << rtcg::PRINT_COLOR::RED << "fail" << rtcg::PRINT_COLOR::ENDCOLOR << std::endl)
      break;
    default:
      RTCG_INFO_STREAM("  {{ . }} = unknown" << std::endl)
      break;
  }
{{-   end }}
{{- end }}
}

{{- range . }}

void Verdict::{{ . }}(rtcg::Outcome new_val)
{
  if ({{ . }}_ == new_val)
    return;

  {{ template "log" "info" }}"Test {{ . }} is now " << new_val << "; was " << {{ . }}_ << "."{{ template "end_log" }}
  {{ . }}_ = new_val;
}
{{- end -}}
