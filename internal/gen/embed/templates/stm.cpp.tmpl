{{/*
stm.cpp.tmpl expands into the state machine for the tester.

It expects the test context as its dot.
*/}}
// The main testing state machine, containing all state used in the test.
class StateMachine : public rtcg::TestCase
{
public:
  StateMachine({{ block "stm_ctor_params" . }}{{ end }});
  Verdict& getVerdict(); // Gets the current verdict.
private:
  Verdict verdict_;
  State state_ = {{ (index .Stm.States 0).ID | cppStateEnum }};
{{- block "stm_fields" . -}}{{- end }}

  // Callbacks
  void timeoutCallback({{ template "timeout_args" }});

{{- range .Transitions }}
  void {{ cppCallbackName .Channel }}({{ template "callback_args" .Channel }});
{{- end }}

  // State entry functions
{{- range .Stm.States }}
  void {{ cppStateEntry .ID }}();
{{- end }}

  void end(rtcg::Status status); // Ends the test with the given status.
};

StateMachine::StateMachine({{ template "stm_ctor_params" . }})
{
  {{ cppStateEntry .Stm.InitialState }}();
  {{- block "stm_ctor" . }}{{ end }}
}

Verdict& StateMachine::getVerdict()
{
  return verdict_;
}

void StateMachine::end(rtcg::Status s)
{
  status_ = s;
{{- block "end" . }}
{{- end }}
}

//
// Callback functions
//

void StateMachine::timeoutCallback({{ block "timeout_args" . }}{{ end }})
{
  {{ template "log" "info" }}("timeout");
  end(rtcg::Status::TIMEOUT);
}

{{- range .Transitions }}

void StateMachine::{{ cppCallbackName .Channel }}({{ template "callback_args" .Channel }})
{
{{- block "callback" . }}
{{-   template "callback.cpp.tmpl" . }}
{{- end -}}
}
{{- end }}


//
// State machine entry functions
//

{{- range .Stm.States }}

void StateMachine::{{ cppStateEntry .ID }}()
{
  state_ = {{ cppStateEnum .ID }};
{{ block "state" . }}
{{- template "state.cpp.tmpl" . -}}
{{- end }}
}
{{- end }}