{{/*
stm.cpp.tmpl expands into the state machine for the tester.

It expects the state machine as its dot.
*/}}

// The main testing state machine.
class StateMachine
{
public:
  StateMachine();

  rtcg::Status getStatus();
  void dumpVerdict();

private:
  Verdict verdict;
  State state = {{ (index .States 0).ID | cppStateEnum }};
  rtcg::Status status = rtcg::Status::RUNNING;

  // Callbacks
{{- range .TransitionSets }}
  void {{ .Channel.Name }}Callback({{ template "callback_args" .Channel }});
{{- end }}

  // State entry functions
{{- range .States }}
  void {{ cppStateEntry .ID }}();
{{- end }}

  void end(rtcg::Status why);
  void transitionTo(State next);
};

StateMachine::StateMachine()
{
  {{ cppStateEntry .InitialState }}();
}

rtcg::Status StateMachine::getStatus()
{
  return status;
}

void StateMachine::end(rtcg::Status why)
{
  status = why;
{{- block "end" . }}
{{- end }}
}

void StateMachine::dumpVerdict()
{
  verdict.dump();
}


//
// Callback functions
//
{{- range .TransitionSets }}

void StateMachine::{{ .Channel.Name }}Callback({{ template "callback_args" .Channel }})
{
{{- block "callback" . }}
{{-   template "callback.cpp.tmpl" . }}
{{- end -}}
}
{{- end }}


//
// State machine entry functions
//

{{- range .States }}

void StateMachine::{{ cppStateEntry .ID }}()
{
  state = {{ cppStateEnum .ID }};
{{ block "state" . }}
{{- template "state.cpp.tmpl" . -}}
{{- end }}
}
{{- end }}