/*
 * Test autogenerated by rtcg
 */

{{ block "includes" . }}
/* System includes: */
#include <stdlib.h>
#include <stdio.h>

{{   block "system_includes" . }}
{{   end }}

/* Includes for this model: */
{{   block "custom_includes" . }}
{{   end }}
{{ end }}

/*
 * Special definitions
 */

/* outcome_t captures an inconclusive, passing, or failing outcome. */
typedef enum outcome {
    INC,
    PASS,
    FAIL
} outcome_t;

const char *
outstr(outcome_t o)
{
    switch (o) {
    case INC:
        return "inconclusive";
    case PASS:
        return "passed";
    case FAIL:
        return "failed";
    }
    return "???";
}

/* Each outcome_index_t maps an outcome to the index of its outcome in the outcome table. */
typedef enum outcome_index {
{{- range $i, $v := .Tests.Values }}
    OUTCOME_{{ $v }} = {{ $i }},
{{- end }}
    NUM_OUTCOMES = {{ len .Tests.Values }}
} outcome_index_t;

void
set_outcome(outcome_t *outcomes, outcome_index_t i, char *test_name, outcome_t new_val)
{
    outcome_t old_val = outcomes[i];
    if (old_val == new_val) {
        return;
    }
    outcomes[i] = new_val;
    printf("test %s is now %s (was %s)\n", test_name, outstr(new_val), outstr(old_val));
}

/* Each state_index_t maps a test state to the index of its function in the states table. */
typedef enum state_index {
    STATE_TIMEOUT = -2,
    STATE_FAIL = -1,
{{- range $i, $s := .States }}
    STATE_{{ $s.ID }} = {{ $i }},
{{- end }}
    NUM_STATES = {{ len .States }}
} state_index_t;

/* state_t is the type of state functions. */
typedef state_index_t (*state_t)(outcome_t *outcomes);

/*
 * Test states
 */

{{- range .States }}

state_index_t
{{ .ID }}(outcome_t *outcomes) {
{{- block "test" . }}
{{- template "test.c.tmpl" . -}}
{{- end }}
}
{{- end }}

/* states is the jump-table for all states in the test, indexed by state_index_t. */
state_t states[{{ len .States}}] = {
{{- range .States }}
    {{ .ID }},
{{- end }}
};

/*
 * Main body
 */

int
main(int argc, char** argv)
{
{{- block "body" . }}
    /* Initialisation code */
{{-   block "init" . }}
    outcome_t *outcomes = calloc(sizeof(outcome_t), NUM_OUTCOMES);
    state_index_t current_state = STATE_{{ (index .States 0).ID }};
{{- end }}

    /* Test code */
{{- block "tester" . }}
    while (STATE_FAIL < current_state) {
        current_state = states[current_state](outcomes);
    }
{{- end }}

    /* Teardown code */
{{- block "aftermath" . }}
    if (current_state == STATE_FAIL) {
        printf("test aborted due to failure\n");
    } else if (current_state == STATE_TIMEOUT) {
        printf("test timed out\n");
    }

    printf("final outcomes: \n");
    {{- range .Tests.Values }}
    printf("  {{ .}} = %s\n", outstr(outcomes[OUTCOME_{{ . }}]));
    {{- end }}

    free(outcomes);
{{- end }}

{{- end }}
}