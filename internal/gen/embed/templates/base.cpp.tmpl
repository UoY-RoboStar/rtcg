//
// Test {{ .Name }}
//
// Test autogenerated by rtcg on {{ .Date }}
//

{{- block "includes" . }}

// System includes
#include <array>
#include <stdlib.h>
#include <stdio.h>

{{-   block "system_includes" . }}
{{-   end }}

// Includes for this model:
{{-   block "custom_includes" . }}
{{-   end }}
{{- end }}

//
// OUTCOMES
//

// An inconclusive, passing, or failing outcome.
enum class Outcome {
    INC,
    PASS,
    FAIL
};

// A string representation of an outcome.
const char* outstr(Outcome o)
{
  switch (o) {
  case Outcome::INC:
    return "inconclusive";
  case Outcome::PASS:
    return "passed";
  case Outcome::FAIL:
    return "failed";
  }
  return "???";
}


//
// TEST METADATA
//
// For non-factorised tests, there will likely only be one test captured by this test case.
//
{{ template "test_meta.cpp.tmpl" .Stm.Tests.Values }}

//
// VERDICTS
//
{{ template "verdict.cpp.tmpl" .Stm.Tests.Values }}


//
// STATE MACHINE
//
{{ template "stm.cpp.tmpl" .Stm.States }}


//
// DRIVER
//

int main(int argc, char** argv)
{
{{- block "body" . }}
  // Initialisation code
{{-   block "init" . }}
  auto* verdict = new Verdict();
  auto current_state = {{ cppStateEnum (index .Stm.States 0).ID }};
{{-   end }}

  // Test code
{{-   block "tester" . }}
  while (State::FAIL < current_state)
    current_state = STATES[static_cast<size_t>(current_state)](*verdict);
{{-   end }}

  // Teardown code
{{-   block "aftermath" . }}
  if (current_state == State::FAIL)
  {
    printf("test aborted due to failure\n");
  }
  else if (current_state == State::TIMEOUT)
  {
    printf("test timed out\n");
  }

  verdict->dump();

  delete verdict;
{{-   end }}
{{- end }}
}